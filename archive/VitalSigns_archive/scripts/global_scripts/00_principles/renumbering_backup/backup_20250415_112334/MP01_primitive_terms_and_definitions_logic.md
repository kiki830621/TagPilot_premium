---
id: "MP01_LOGIC"
title: "Primitive Terms and Definitions - Logical Formulation"
type: "meta-principle"
date_created: "2025-04-03"
date_modified: "2025-04-03"
author: "Claude"
derives_from:
  - "MP00": "Axiomatization System"
influences:
  - "P02": "Structural Blueprint"
  - "P03": "Project Principles"
  - "P04": "Script Separation"
  - "MP29": "Terminology Axiomatization"
alternative_of:
  - "MP01": "Primitive Terms and Definitions"
---

# Primitive Terms and Definitions - Logical Formulation

This document presents the logical formulation of the primitive terms and their relationships in the precision marketing system, using predicate logic and set theory notation.

## Primitive Predicates and Sets

Let us define the following primitive sets and predicates:

### Core Sets

- `Code`: The set of all executable elements in the system
- `Data`: The set of all information units used in the system
- `Guidance`: The set of all elements that guide system design and implementation
- `Organization`: The set of all elements that organize the system

### Type Hierarchies (Set Inclusion)

```
Function ⊂ Code
Component ⊂ Code
Module ⊂ Code
Sequence ⊂ Organization
Derivation ⊂ Organization

MetaPrinciple ⊂ Guidance
Principle ⊂ Guidance
Rule ⊂ Guidance
Instance ⊂ Implementation

RawData ⊂ Data
ProcessedData ⊂ Data
Parameter ⊂ Data
DefaultValue ⊂ Data
```

### Primitive Predicates

- `implements(x, y)`: x implements y (e.g., a component implements an interface)
- `contains(x, y)`: x contains y (e.g., a module contains components)
- `configures(x, y)`: x configures y (e.g., a parameter configures a component)
- `governs(x, y)`: x governs y (e.g., a principle governs implementation)
- `generates(x, y)`: x generates y (e.g., a platform generates raw data)
- `transforms(x, y, z)`: x transforms y into z (e.g., a function transforms raw data into processed data)
- `accesses(x, y)`: x accesses y (e.g., a component accesses a data source)
- `has_attribute(x, a, v)`: x has attribute a with value v

## Axioms

The following axioms define the fundamental relationships between primitive terms:

### Disjointness Axioms

1. ∀x, ¬(x ∈ Parameter ∧ x ∈ DefaultValue)
   - No entity can be both a parameter and a default value

2. ∀x, ¬(x ∈ MetaPrinciple ∧ x ∈ Principle)
   - No entity can be both a meta-principle and a principle

3. ∀x, ¬(x ∈ Principle ∧ x ∈ Rule)
   - No entity can be both a principle and a rule

4. ∀x, ¬(x ∈ Module ∧ x ∈ Sequence)
   - No entity can be both a module and a sequence

### Structural Axioms

5. ∀c ∈ Component, ∃ui, server, defaults [
   has_attribute(c, "ui_part", ui) ∧
   has_attribute(c, "server_part", server) ∧
   has_attribute(c, "defaults_part", defaults)
   ]
   - Every component has UI, server, and defaults parts

6. ∀m ∈ Module, ∃c ∈ Component [contains(m, c)]
   - Every module contains at least one component

7. ∀s ∈ Sequence, ∃m ∈ Module [contains(s, m)]
   - Every sequence contains at least one module

8. ∀p ∈ Parameter, ∃n, v, s [
   has_attribute(p, "name", n) ∧
   has_attribute(p, "value", v) ∧
   has_attribute(p, "scope", s)
   ]
   - Every parameter has name, value, and scope attributes

9. ∀d ∈ DefaultValue, ∃c ∈ Component [
   has_attribute(d, "component", c)
   ]
   - Every default value is associated with a component

### Hierarchical Axioms

10. ∀mp ∈ MetaPrinciple, ∃p ∈ Principle [governs(mp, p)]
    - Every meta-principle governs at least one principle

11. ∀p ∈ Principle, ∃r ∈ Rule [governs(p, r)]
    - Every principle governs at least one rule

12. ∀r ∈ Rule, ∃i ∈ Instance [governs(r, i)]
    - Every rule governs at least one instance

### Data Flow Axioms

13. ∀rd ∈ RawData, ∃p [generates(p, rd) ∧ p ∈ Platform]
    - All raw data is generated by some platform

14. ∀pd ∈ ProcessedData, ∃rd ∈ RawData, f ∈ Function [transforms(f, rd, pd)]
    - All processed data is transformed from raw data by some function

15. ∀ds ∈ DataSource, ∃pd ∈ ProcessedData [accesses(ds, pd)]
    - Every data source accesses some processed data

16. ∀p ∈ Parameter, ∃c ∈ Component [configures(p, c)]
    - Every parameter configures some component

## Derived Predicates

From the primitive predicates, we can derive additional relationships:

17. depends_on(x, y) ≡ ∃z [accesses(x, z) ∧ accesses(y, z)]
    - x depends on y if they access the same resource

18. compatible(x, y) ≡ ∀z [configures(z, x) → configures(z, y)]
    - x is compatible with y if all parameters that configure x also configure y

19. extends(x, y) ≡ x ∈ Component ∧ y ∈ Component ∧ ∀f [implements(y, f) → implements(x, f)]
    - x extends y if x implements at least all the functionality of y

## Type Hierarchies as Inference Rules

We can express the type hierarchies as logical inference rules:

20. x ∈ Function → x ∈ Code
    - If x is a function, then x is code

21. x ∈ Parameter → x ∈ Data
    - If x is a parameter, then x is data

22. x ∈ MetaPrinciple → x ∈ Guidance
    - If x is a meta-principle, then x is guidance

23. x ∈ Module → x ∈ Organization
    - If x is a module, then x is an organization element

## Implementation and Organization Relationships

24. ∀c ∈ Component, ∃f ∈ Function [implements(c, f)]
    - Every component implements at least one function

25. ∀m ∈ Module, ∃c ∈ Component [contains(m, c)]
    - Every module contains at least one component

26. ∀s ∈ Sequence, ∃m1, m2 ∈ Module [
    contains(s, m1) ∧ contains(s, m2) ∧ m1 ≠ m2 ∧
    has_attribute(s, "order", o) ∧
    (o(m1) < o(m2) ∨ o(m1) > o(m2))
    ]
    - Every sequence contains at least two distinct modules with a defined order

27. ∀d ∈ Derivation, ∃s ∈ Sequence [documents(d, s)]
    - Every derivation documents at least one sequence

## Example Logical Statements

The following statements demonstrate how this logical formulation can be applied:

```
// A component implementing the UI-Server-Defaults triple
c ∈ Component ∧
has_attribute(c, "ui_part", ui) ∧
has_attribute(c, "server_part", server) ∧
has_attribute(c, "defaults_part", defaults)

// A parameter configuring a component through YAML
p ∈ Parameter ∧
has_attribute(p, "name", "refresh_interval") ∧
has_attribute(p, "value", 300) ∧
has_attribute(p, "scope", "macro") ∧
configures(p, c) ∧ c ∈ Component

// A default value provided by a component
d ∈ DefaultValue ∧
has_attribute(d, "name", "refresh_interval") ∧
has_attribute(d, "value", 60) ∧
has_attribute(d, "component", c) ∧ c ∈ Component

// The relationship between meta-principles and principles
mp ∈ MetaPrinciple ∧
p ∈ Principle ∧
governs(mp, p)
```

## Terminological Categories as Logical Classes

We can formalize the terminological categories as logical classes with properties:

### Class: Parameter
```
Class Parameter {
  Properties:
    name: String
    value: Any
    scope: String
    specified_in: "YAML"
    source: "External"
  
  Constraints:
    ∀p ∈ Parameter, ¬(p ∈ DefaultValue)
}
```

### Class: DefaultValue
```
Class DefaultValue {
  Properties:
    name: String
    value: Any
    component: Component
    specified_in: "Component"
    source: "Internal"
  
  Constraints:
    ∀d ∈ DefaultValue, ¬(d ∈ Parameter)
}
```

### Class: Component
```
Class Component {
  Properties:
    id: String
    ui_part: Code
    server_part: Code
    defaults_part: Code
    
  Methods:
    implements(Interface)
    requires(Component)
    provides(Function)
}
```

## Conclusion

This logical formulation of primitive terms and definitions provides a rigorous foundation for the precision marketing system's vocabulary. By expressing relationships in predicate logic and set theory, we create an unambiguous reference that complements the natural language version of MP01.

The formal notation allows for:
1. Precise reasoning about term relationships
2. Validation of system consistency
3. Derivation of new relationships through logical inference
4. Clear distinction between different types of terms

Together with the natural language version, this logical formulation ensures that the system's terminology is both accessible to humans and amenable to formal analysis.
