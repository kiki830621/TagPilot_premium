# D02: Customer View Filtering Derivation

## Overview

This derivation extends D01 (DNA Analysis) to create filtered customer views based on multiple filter condition combinations. It transforms sales data into filtered views that can be accessed by micro-components to display personalized content for specific filter combinations.

## Premise

- D01 has been completed, creating processed sales data and basic customer DNA profiles
- Different filter combinations will determine what data is visible to micro-components
- Filter conditions include time periods, product lines, geographic areas, and data sources

## Key Concepts

### Filter Dimensions

The filtering system is built on four key dimensions:

1. **Time Condition**:
   - `now`: All historical data (no time restriction)
   - `m1year`: Data from the past year to present
   - `m1quarter`: Data from the past quarter to present
   - `m1month`: Data from the past month to present

2. **Product Line**:
   - `0`: Special value representing all products
   - `1, 2, 3, ...`: Specific product line identifiers

3. **Geographic Region**:
   - `ALL`: Special value representing all geographic regions
   - `CA, NY, TX, ...`: Standard state/province codes

4. **Data Source**:
   - Platform-specific distribution channels (e.g., `amazon`, `ebay`, `retail`)

### Condition Grid

The system generates a comprehensive grid of all possible filter combinations using a Cartesian product. Components are defined in configuration files and expanded at runtime.

## Derivation Steps

### D02_00: Create Filtered Schema

Create a dedicated schema to store filtered views:

```NSQL
CREATE SCHEMA processed_data.filtered
```

### D02_01: Create Condition Grid

Grid components are defined in the parameters file and processed by a configuration script:

```NSQL
# In app_data/parameters/list_grid_components.R
grid_components <- list(
  time_condition = c("now", "m1year", "m1quarter", "m1month"),
  product_line_id_filter = c(0, 1, 2, 3, ...), # 0 = all products
  state_filter = c("ALL", "CA", "NY", "TX", ...),
  source_filter = c("amazon", "ebay", "retail", ...)
)

# In global_scripts/22_initializations/sc_grid_components.R
source("app_data/parameters/list_grid_components.R")
condition_grids <- get_condition_grid(grid_components)
```

Define special time conditions relative to current data:

```NSQL
time_now <- max(processed_data.df_{source}_sales$time)

time_conditions <- list(
  "m1year" = time_now %m+% years(-1),
  "m1quarter" = time_now %m+% months(-3),
  "m1month" = time_now %m+% months(-1),
  "now" = -Inf  # "now" represents no time restriction
)
```

Alternative implementation with fully abstract components:

```NSQL
# Abstract definition of grid components
# These could be loaded from a configuration file, database, or defined inline
DEFINE grid_components AS {
  # Time dimension with arbitrary values
  time_condition: [
    # Values defined according to business requirements
    # Special value "now" represents no time restriction
    "now", "m1year", "m1quarter", "m1month", 
    # Additional values could be included
    "m2year", "ytd", "custom", ...
  ],
  
  # Product dimension with arbitrary values
  # Special value 0 represents "all products"
  product_line_id_filter: [0, 1, 2, 3, ...],
  
  # Geographic dimension with arbitrary values
  # Special value "ALL" represents all regions
  state_filter: ["ALL", "CA", "NY", "TX", ...],
  
  # Source dimension with arbitrary values
  source_filter: ["amazon", "ebay", "retail", ...]
}

# Generate the full cartesian product for all combinations
FUNCTION generate_condition_grid(components) {
  # This is an abstract representation
  # The actual implementation may vary by platform
  RETURN CARTESIAN_PRODUCT(components)
}

# Generate the grid
condition_grid <- generate_condition_grid(grid_components)

# Define time thresholds for any time condition pattern
FUNCTION get_time_threshold(time_condition) {
  CASE
    # Standard periods
    WHEN time_condition == "m1year" THEN time_now - INTERVAL 1 YEAR
    WHEN time_condition == "m1quarter" THEN time_now - INTERVAL 3 MONTH
    WHEN time_condition == "m1month" THEN time_now - INTERVAL 1 MONTH
    WHEN time_condition == "m2year" THEN time_now - INTERVAL 2 YEAR
    WHEN time_condition == "ytd" THEN TRUNC(time_now, 'YEAR')
    
    # Special case: "now" represents no time restriction
    WHEN time_condition == "now" THEN NULL
    
    # Custom patterns could be parsed from the condition value
    WHEN time_condition LIKE "m%month" THEN 
      time_now - INTERVAL EXTRACT(SUBSTRING(time_condition, 2, 1)) MONTH
    WHEN time_condition LIKE "last%days" THEN
      time_now - INTERVAL EXTRACT(SUBSTRING(time_condition, 5)) DAY
      
    # Default case
    ELSE NULL
  END
}
```

## Condition Grid Explanation

The condition grid is a fundamental concept in this derivation that enables systematic filtering of customer data. It represents a comprehensive matrix of all possible filter combinations that micro-components may need to access.

### Structure and Purpose

The condition grid:
- Creates a Cartesian product of all possible filter value combinations
- Serves as a configuration map for pre-computing filtered datasets
- Ensures all micro-components can access appropriately filtered data
- Provides a consistent filtering mechanism across the application

### Key Condition Dimensions

1. **Time Conditions**:
   - Represents different time horizons for analyzing customer behavior
   - `now`: Current data without time restriction (all historical data)
   - `m1year`: Data from 1 year ago to present
   - `m1quarter`: Data from 3 months ago to present
   - `m1month`: Data from 1 month ago to present
   - Dynamically calculated relative to the latest available data

2. **Product Line Filters**:
   - Segments customers by product categories they've purchased
   - Integer IDs representing different product lines
   - `0`: Special value representing "all products"
   - Other values: Specific product line identifiers

3. **Geographic Filters**:
   - Segments customers by geographic location
   - State/province codes for regional analysis
   - `ALL`: Special value representing all geographic areas
   - Standard state/province codes for specific regions

4. **Source Filters**:
   - Segments customers by sales channel/platform
   - Different distribution channels or data sources
   - Examples: "amazon", "ebay", "retail", "web"

### Implementation Considerations

- The condition grid can grow large with many combinations
- Not all combinations may be meaningful for business analysis
- Time conditions require special handling with date manipulation
- Each platform may have different valid values for certain dimensions

### Example Grid Generation

```NSQL
# Using the helper function from sc_grid_components.R
subset_condition_grid <- get_filtered_condition_grid(
  time_values = c("now", "m1quarter"),
  product_values = c(0, 1, 2),
  state_values = c("ALL", "CA", "NY"),
  source_values = c("amazon", "ebay")
)

# This creates 2 × 3 × 3 × 2 = 36 filter combinations
print(nrow(subset_condition_grid))
# [1] 36
```

### D02_02: Create Filtered Sales Views

For each filter combination in the condition grid, create virtual views that apply the appropriate filters:

```NSQL
FOR EACH condition IN condition_grids:
  FILTER processed_data.df_{source}_sales BY condition
  TRANSFORM TO cbind(filtered_sales, condition) 
  STORE AS VIRTUAL processed_data.filtered.df_sales
```

#### Filtering Implementation Details

The filtering logic for each condition type requires special handling:

1. **Time Condition Filtering**:
   - `now`: No time restriction (includes all historical data)
   - Other time values: Filter transactions after the specified relative date
   
   ```NSQL
   # For time conditions
   FILTER sales_data BY
     CASE 
       WHEN time_condition == "now" THEN TRUE  # All data 
       WHEN time_condition == "m1year" THEN transaction_date >= (time_now %m+% years(-1))
       WHEN time_condition == "m1quarter" THEN transaction_date >= (time_now %m+% months(-3))
       WHEN time_condition == "m1month" THEN transaction_date >= (time_now %m+% months(-1))
     END
   ```

2. **Product Line Filtering**:
   - Special case: When `product_line_id_filter == 0`, include all products
   - Regular case: Filter for specific product line ID
   
   ```NSQL
   # For product filtering
   FILTER sales_data BY
     CASE
       WHEN product_line_id_filter == 0 THEN TRUE  # Include all products
       ELSE product_line_id == product_line_id_filter
     END
   ```

3. **Geographic Filtering**:
   - Special case: When `state_filter == "ALL"`, include all states
   - Regular case: Filter for specific state
   
   ```NSQL
   # For geographic filtering
   FILTER sales_data BY
     CASE
       WHEN state_filter == "ALL" THEN TRUE  # Include all states
       ELSE state == state_filter
     END
   ```

4. **Source Filtering**:
   - Always filter for the specific source (no special cases)
   
   ```NSQL
   # For source filtering
   FILTER sales_data BY source == source_filter
   ```

Alternative implementation with abstract filter function:

```NSQL
# Define a general-purpose filter handler for any sales data
FUNCTION filter_sales_data(dataset, filter_condition) {
  # Apply time filter 
  time_threshold = get_time_threshold(filter_condition.time_condition)
  IF time_threshold IS NOT NULL THEN
    dataset = FILTER dataset WHERE transaction_date >= time_threshold
  END IF
  
  # Apply product filter with special handling for "all products" value (0)
  IF filter_condition.product_line_id_filter != 0 THEN
    dataset = FILTER dataset WHERE product_line_id = filter_condition.product_line_id_filter
  END IF
  
  # Apply geographic filter with special handling for "ALL" value
  IF filter_condition.state_filter != "ALL" THEN
    dataset = FILTER dataset WHERE state = filter_condition.state_filter
  END IF
  
  # Apply source filter (always required)
  dataset = FILTER dataset WHERE source = filter_condition.source_filter
  
  # Add filter columns for tracking and querying
  dataset = EXTEND dataset WITH [
    filter_condition.source_filter AS source_filter,
    filter_condition.time_condition AS time_condition,
    filter_condition.product_line_id_filter AS product_line_id_filter,
    filter_condition.state_filter AS state_filter
  ]
  
  RETURN dataset
}

# Create a view for each condition in the grid
FOR EACH condition IN condition_grid {
  # Generate view name dynamically based on the specific values
  # This allows for flexible naming conventions based on the platform
  view_name = GENERATE_VIEW_NAME("processed_data.filtered.df_sales_", condition)
  
  # Create the filtered view using the general filter function
  CREATE VIRTUAL VIEW view_name AS
    SELECT * FROM filter_sales_data(processed_data.df_sales, condition)
}
```

#### Virtual View Implementation

The views are implemented as virtual database objects rather than materialized tables to save storage space and ensure data is always current:

```NSQL
# Example SQL implementation
CREATE VIEW processed_data.filtered.df_sales_amazon_now_all_ca AS
SELECT 
  s.*,
  'amazon' AS source_filter,
  'now' AS time_condition,
  0 AS product_line_id_filter,
  'CA' AS state_filter
FROM 
  processed_data.df_sales s
WHERE 
  s.source = 'amazon' AND
  s.state = 'CA';
```

Using virtual views provides several benefits:
- No duplication of storage
- Automatic updates when base tables change
- Conceptual organization without physical overhead
- Clear documentation of filter conditions

#### Naming Convention for Views

Views follow a naming convention to identify their filter configuration:

```
processed_data.filtered.df_sales_{source}_{time}_{product}_{state}
```

For example:
- `df_sales_amazon_now_0_all`: Amazon sales, all time periods, all products, all states
- `df_sales_retail_m1year_1_ca`: Retail sales from past year, product line 1, California only

### D02_03: Create Customer-Centric Filtered Views

Transform filtered sales data to customer-focused views, aggregating transaction-level data to customer-level metrics:

```NSQL
FOR EACH condition IN condition_grids:
  TRANSFORM processed_data.filtered.df_sales 
  TO VIRTUAL processed_data.filtered.df_sales_by_customer
```

Alternative implementation with configurable metrics:

```NSQL
# Define customer metrics for any filter condition
# This function allows for extensible metrics based on business requirements
FUNCTION compute_customer_metrics(dataset, metrics_config) {
  # Define base aggregation
  base_metrics = [
    # Core DNA metrics from D01
    SUM(amount) AS m_value,
    DATEDIFF(day, MAX(transaction_date), CURRENT_DATE) AS r_value,
    COUNT(*) AS f_value,
    
    # Standard customer metrics
    MIN(transaction_date) AS first_purchase_date,
    MAX(transaction_date) AS last_purchase_date,
    AVG(amount) AS average_order_value
  ]
  
  # Add optional metrics based on configuration
  IF metrics_config.include_product_metrics THEN
    base_metrics = APPEND(base_metrics, [
      COUNT(DISTINCT product_id) AS product_count,
      JSON_AGG(DISTINCT product_category) AS product_categories
    ])
  END IF
  
  IF metrics_config.include_time_metrics THEN
    base_metrics = APPEND(base_metrics, [
      AVG(DATEDIFF(day, LAG(transaction_date) OVER (
        PARTITION BY customer_id ORDER BY transaction_date
      ), transaction_date)) AS ipt_mean
    ])
  END IF
  
  # Define NES status calculation if requested
  IF metrics_config.calculate_nes THEN
    nes_expression = CASE
      WHEN COUNT(*) = 1 AND MIN(transaction_date) > CURRENT_DATE - INTERVAL 30 DAY
        THEN 'N'  # New customer
      WHEN MAX(transaction_date) > CURRENT_DATE - INTERVAL 60 DAY
        THEN 'E0' # Existing active
      WHEN MAX(transaction_date) > CURRENT_DATE - INTERVAL 180 DAY
        THEN 'S1' # Sleeping 1-6 months
      WHEN MAX(transaction_date) > CURRENT_DATE - INTERVAL 365 DAY
        THEN 'S2' # Sleeping 6-12 months
      ELSE 'S3'   # Sleeping >12 months
    END AS nes_status
    
    base_metrics = APPEND(base_metrics, [nes_expression])
  END IF
  
  # Return customer-aggregated dataset
  RETURN SELECT 
    customer_id,
    base_metrics,
    # Preserve all filter dimensions from original dataset
    dataset.source_filter,
    dataset.time_condition,
    dataset.product_line_id_filter,
    dataset.state_filter
  FROM dataset
  GROUP BY customer_id
}

# Create customer-centric views for each filter condition
FOR EACH condition IN condition_grid {
  # Get the source view name for this condition
  sales_view_name = GENERATE_VIEW_NAME("processed_data.filtered.df_sales_", condition)
  
  # Generate customer view name
  customer_view_name = GENERATE_VIEW_NAME("processed_data.filtered.df_sales_by_customer_", condition)
  
  # Define metrics configuration based on condition or business rules
  # This allows different metrics for different filter combinations if needed
  metrics_config = {
    include_product_metrics: TRUE,
    include_time_metrics: TRUE,
    calculate_nes: TRUE
  }
  
  # Create the virtual view with customer metrics
  CREATE VIRTUAL VIEW customer_view_name AS
    SELECT * FROM compute_customer_metrics(sales_view_name, metrics_config)
}
```

#### Customer Aggregation Process

The customer-centric views apply these transformations:

1. **Group by Customer ID**: Collapse all transactions for each customer
2. **Calculate Customer Metrics**: Derive key metrics for analytics 
3. **Preserve Filter Conditions**: Maintain all filter dimensions

```NSQL
# Example customer-centric view implementation
CREATE VIEW processed_data.filtered.df_sales_by_customer_amazon_now_0_all AS
SELECT 
  customer_id,
  COUNT(*) AS transaction_count,
  MIN(transaction_date) AS first_purchase_date,
  MAX(transaction_date) AS last_purchase_date,
  SUM(amount) AS total_spent,
  AVG(amount) AS average_order_value,
  'amazon' AS source_filter,
  'now' AS time_condition,
  0 AS product_line_id_filter,
  'ALL' AS state_filter
FROM 
  processed_data.filtered.df_sales_amazon_now_0_all
GROUP BY 
  customer_id;
```

#### Customer DNA Integration

These customer-centric views are designed to integrate with customer DNA profiles from D01:

1. **M (Monetary)**: Total spent by customer
2. **R (Recency)**: Time since last purchase
3. **F (Frequency)**: Number of transactions

Additional metrics may include:
- Average inter-purchase time
- Product category distribution
- Customer lifetime value estimates
- NES (New/Existing/Sleeping) classification

#### Access Pattern for Components

Micro-components should access these customer-centric views for optimal performance:

```r
# Example component data access
customer_data <- tbl2(conn, "processed_data.filtered.df_sales_by_customer") %>%
  filter(
    source_filter == input$source,
    time_condition == input$time_horizon,
    product_line_id_filter == as.integer(input$product_line),
    state_filter == input$region
  ) %>%
  collect()
```

## Implementation Details

Each platform requires specific implementations following this abstract derivation:

1. Filter application must respect the platform's data structure
2. Time conditions use relative offsets from the latest available data
3. Product line filtering uses integers with 0 representing "all products"
4. Geographic filtering uses state codes with "ALL" representing all states
5. Source filtering corresponds to available data sources for each platform

## Implementation Guidelines

1. **Configuration Management**:
   - Store grid components in `app_data/parameters/list_grid_components.R`
   - Use `22_initializations/sc_grid_components.R` for grid generation functions
   - Allow runtime filtering of the full grid for testing and development

2. **View Creation**:
   - Use virtual views to minimize storage overhead
   - Follow consistent naming conventions for views
   - Include all filter dimensions as columns in the views
   - Implement special case handling for "all" values (0, ALL, now)

3. **Performance Optimization**:
   - Create indexes on filter dimensions in base tables
   - Consider materializing frequently accessed views
   - Use query result caching where appropriate

4. **Platform-Specific Implementation**:
   - Use best practices for view creation in target database systems
   - Ensure proper type handling for filter dimensions
   - Follow platform naming conventions

## Dependencies

- D01 must be completed first to generate the base sales data
- The condition grid components must be defined in `app_data/parameters/list_grid_components.R`
- The grid configuration script `22_initializations/sc_grid_components.R` must be sourced
- Time conditions must be dynamically calculated based on the latest available data

## Success Criteria

1. All condition combinations in the grid have corresponding filtered views
2. Filtered views maintain all necessary columns from the original sales data
3. Customer-centric views properly aggregate data at the customer level
4. Filter conditions are stored alongside data for easy reference
5. Views can be efficiently queried by micro-components

## Related Principles

- R039: Derivation Platform Independence
- R040: Derivation Implementation Naming
- R041: Derivation Folder Structure
- R116: Enhanced Data Access with tbl2
- MP027: Integrated Natural SQL Language
- MP058: Global Parameter Organization