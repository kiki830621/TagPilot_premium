---
title: "R067: Functional Encapsulation Rule"
subtitle: "Extracting Reusable Functions from Code Blocks"
id: r067
type: rule
date_created: "2025-04-08"
author: "Claude"
implements:
  - mp016
  - mp017
  - mp018
related_to:
  - r021
  - p012
applies_to:
  - d01
  - d02
  - customer-data-processing
format:
  html:
    toc: true
    code-fold: show
---

# Functional Encapsulation Rule {#sec-functional-encapsulation}

::: {.callout-important}
## Core Rule
All code blocks that exhibit functional characteristics must be explicitly encapsulated as named functions. A code block is considered "function-like" if it has identifiable inputs and produces determinable outputs or side effects.
:::

## Conceptual Framework {#sec-framework}

The Functional Encapsulation Rule establishes that code should be organized around the fundamental unit of a function. This rule recognizes that functional encapsulation:

1. **Improves Testability**: Encapsulated functions can be tested in isolation
2. **Enhances Reusability**: Named functions can be called from multiple contexts  
3. **Clarifies Intent**: Function names document the purpose of code blocks
4. **Reduces Complexity**: Breaking code into functions simplifies reasoning
5. **Enables Composition**: Functions can be combined to build complex behavior

## Identifying Function-Like Code {#sec-identifying}

A code block is considered "function-like" if it has one or more of these characteristics:

### Key Indicators

```{r}
#| label: function-indicators
#| eval: false

# 1. Input Dependence: Processes specific data inputs
if (nrow(customer_data) > 0) {
  processed_data <- customer_data %>%
    filter(status == "active") %>%
    group_by(segment) %>%
    summarize(total_value = sum(purchase_amount))
}

# 2. Output Generation: Produces defined results
metrics <- data.frame(
  customer_count = nrow(customers),
  avg_purchase = mean(customers$purchase_amount),
  retention_rate = sum(customers$returning) / nrow(customers)
)

# 3. Error Handling: Contains try/catch logic
tryCatch({
  connection <- dbConnect(duckdb::duckdb(), "app_data.duckdb")
  data <- dbGetQuery(connection, "SELECT * FROM customers")
  dbDisconnect(connection)
}, error = function(e) {
  warning("Database connection failed: ", e$message)
  data <- NULL
})

# 4. Logical Cohesion: Performs single conceptual operation
customer_segments <- customers %>%
  mutate(
    rfm_score = calculate_rfm_score(recency, frequency, monetary),
    segment = case_when(
      rfm_score >= 400 ~ "Champions",
      rfm_score >= 300 ~ "Loyal Customers", 
      rfm_score >= 200 ~ "Potential Loyalists",
      TRUE ~ "At Risk"
    )
  )
```

## D-Series Application {#sec-d-series}

### Current Function-Like Code in D01 and D02

Analysis of @d01 and @d02 reveals multiple function-like code blocks that should be extracted:

::: {.callout-warning}
## Identified Function-Like Blocks

1. **Data Standardization Logic** (45+ lines, repeated in both D01 and D02)
2. **Customer Aggregation Logic** (32+ lines, nearly identical implementations)  
3. **RFM Calculation Logic** (56+ lines, complex mathematical operations)
4. **Filter Application Logic** (28+ lines, conditional processing)
:::

### Example: Data Standardization Block

#### Before: Inline Code (Violates R067)

```{r}
#| label: before-standardization
#| eval: false

# Repeated in both D01 and D02 with minor variations
df_amazon_sales_standardized <- df_amazon_sales %>% 
  rename(
    lineproduct_price = product_price,
    payment_time = time
  ) %>% 
  mutate(
    customer_id = as.integer(as.factor(ship_postal_code))
  ) %>% 
  drop_na(customer_id) %>%
  # Add platform identifier
  mutate(
    platform_id = "amz"
  ) %>% 
  # Join with product line dictionary by ASIN
  left_join(
    df_product_profile_dictionary, 
    by = "asin"
  ) %>%
  # Additional processing steps...
  filter(!is.na(product_line_id)) %>%
  mutate(
    transaction_date = as.Date(payment_time),
    amount_numeric = as.numeric(lineproduct_price)
  )
```

#### After: Extracted Function (Follows R067)

```{r}
#| label: after-standardization
#| eval: false

#' Standardize sales data with consistent field mapping
#' 
#' Transforms raw sales data into standardized format with consistent
#' field names, data types, and platform identification.
#' 
#' @param raw_sales_data Raw sales data frame
#' @param platform_id Platform identifier (e.g., "amz", "ebay")
#' @param product_dictionary Product line mapping dictionary
#' @return Standardized sales data frame
#' @examples
#' standardized <- standardize_sales_data(amazon_raw, "amz", product_dict)
#' 
fn_standardize_sales_data <- function(raw_sales_data, platform_id, product_dictionary) {
  # Input validation
  if (is.null(raw_sales_data) || nrow(raw_sales_data) == 0) {
    warning("Empty or NULL sales data provided")
    return(data.frame())
  }
  
  # Core standardization logic
  standardized_data <- raw_sales_data %>% 
    rename(
      lineproduct_price = product_price,
      payment_time = time
    ) %>% 
    mutate(
      customer_id = as.integer(as.factor(ship_postal_code)),
      platform_id = platform_id
    ) %>% 
    drop_na(customer_id) %>%
    # Join with product line dictionary
    left_join(product_dictionary, by = "asin") %>%
    # Type conversions
    filter(!is.na(product_line_id)) %>%
    mutate(
      transaction_date = as.Date(payment_time),
      amount_numeric = as.numeric(lineproduct_price)
    )
  
  # Output validation
  if (nrow(standardized_data) == 0) {
    warning("Standardization resulted in empty dataset")
  }
  
  return(standardized_data)
}

# Usage in D01 and D02
df_amazon_sales_standardized <- fn_standardize_sales_data(
  df_amazon_sales, 
  "amz", 
  df_product_profile_dictionary
)
```

### Example: Customer Aggregation Block

#### Before: Duplicated Logic

```{r}
#| label: before-aggregation
#| eval: false

# Similar logic appears in both D01 and D02
df_product_line_by_customer <- df_current_product_line %>%
  group_by(customer_id) %>%
  summarize(
    total_spent = sum(lineproduct_price, na.rm = TRUE),
    times = n(),
    first_purchase = min(payment_time, na.rm = TRUE),
    last_purchase = max(payment_time, na.rm = TRUE),
    platform_id = first(platform_id),
    product_line_id = first(product_line_id),
    .groups = "drop"
  ) %>%
  # Calculate additional metrics
  mutate(
    ipt = as.numeric(difftime(last_purchase, first_purchase, units = "days")),
    r_value = as.numeric(difftime(Sys.time(), last_purchase, units = "days")),
    f_value = times,
    m_value = total_spent / times,
    product_line_id_filter = current_product_line_id
  )
```

#### After: Extracted Function

```{r}
#| label: after-aggregation  
#| eval: false

#' Aggregate transaction data to customer level
#' 
#' Transforms transaction-level data into customer-level aggregations
#' with standard metrics (RFM, IPT, etc.)
#' 
#' @param transaction_data Transaction-level data frame
#' @param product_line_filter Product line filter identifier
#' @return Customer-level aggregated data frame
#' 
fn_aggregate_to_customer_level <- function(transaction_data, product_line_filter) {
  # Input validation
  required_fields <- c("customer_id", "lineproduct_price", "payment_time")
  missing_fields <- setdiff(required_fields, names(transaction_data))
  if (length(missing_fields) > 0) {
    stop("Missing required fields: ", paste(missing_fields, collapse = ", "))
  }
  
  # Core aggregation
  customer_aggregated <- transaction_data %>%
    group_by(customer_id) %>%
    summarize(
      total_spent = sum(lineproduct_price, na.rm = TRUE),
      times = n(),
      first_purchase = min(payment_time, na.rm = TRUE),
      last_purchase = max(payment_time, na.rm = TRUE),
      platform_id = first(platform_id),
      product_line_id = first(product_line_id),
      .groups = "drop"
    ) %>%
    # Calculate derived metrics
    mutate(
      ipt = as.numeric(difftime(last_purchase, first_purchase, units = "days")),
      r_value = as.numeric(difftime(Sys.time(), last_purchase, units = "days")),
      f_value = times,
      m_value = total_spent / times,
      product_line_id_filter = product_line_filter
    )
  
  return(customer_aggregated)
}

# Usage
df_customer_aggregated <- fn_aggregate_to_customer_level(
  df_current_product_line, 
  current_product_line_id
)
```

## Implementation Process {#sec-implementation}

### Step 1: Identify Function-Like Code

Review codebase for blocks that exhibit functional characteristics:

```{r}
#| label: identification-checklist
#| eval: false

# Identification checklist:
# ✓ Complex procedural blocks (>10 lines)
# ✓ Error-handling blocks with try/catch
# ✓ Data processing blocks with clear input/output
# ✓ Initialization sequences
# ✓ Blocks with clear logical cohesion
# ✓ Code that appears in multiple places (even with variations)
```

### Step 2: Extract Functions

For each identified code block:

1. **Determine Parameters**: What external data does the code block use?
2. **Determine Return Value**: What results or side effects does it produce?
3. **Create Function**: Move code to properly named function with documentation
4. **Replace Original**: Replace code block with function call

### Step 3: File Organization

Following @r021 (One Function One File):

```
global_scripts/04_utils/
├── fn_standardize_sales_data.R
├── fn_aggregate_to_customer_level.R  
├── fn_calculate_rfm_metrics.R
├── fn_apply_filter_conditions.R
└── fn_validate_data_structure.R
```

## Function Documentation Requirements {#sec-documentation}

Each extracted function must include:

```{r}
#| label: documentation-template
#| eval: false

#' Brief description of what the function does
#'
#' Longer description providing context and implementation details.
#' Explain any complex logic or business rules.
#'
#' @param param1 Description of first parameter
#' @param param2 Description of second parameter  
#' @return Description of return value
#' @examples
#' result <- my_function(data, "config")
#' @seealso Related functions or principles
#' @note Any important implementation notes
#'
my_function <- function(param1, param2) {
  # Implementation with clear variable names
  # Error handling where appropriate
  # Input validation as needed
  
  return(result)
}
```

## Testing Extracted Functions {#sec-testing}

For significant functions, create unit tests:

```{r}
#| label: testing-example
#| eval: false

# test_fn_standardize_sales_data.R
test_that("standardize_sales_data handles normal input", {
  # Arrange
  raw_data <- data.frame(
    product_price = c(10.99, 25.50),
    time = c("2025-01-01", "2025-01-02"),
    ship_postal_code = c("12345", "67890"),
    asin = c("A123", "B456")
  )
  
  product_dict <- data.frame(
    asin = c("A123", "B456"),
    product_line_id = c(1, 2)
  )
  
  # Act
  result <- fn_standardize_sales_data(raw_data, "test", product_dict)
  
  # Assert
  expect_equal(nrow(result), 2)
  expect_true("customer_id" %in% names(result))
  expect_true("platform_id" %in% names(result))
  expect_equal(unique(result$platform_id), "test")
})

test_that("standardize_sales_data handles empty input", {
  result <- fn_standardize_sales_data(data.frame(), "test", data.frame())
  expect_equal(nrow(result), 0)
})
```

## Benefits of Functional Encapsulation {#sec-benefits}

1. **Enhanced Testability**: Functions can be tested in isolation
2. **Improved Maintainability**: Functions are easier to update and debug
3. **Better Code Organization**: Functions provide natural modularity
4. **Clearer Intent**: Function names document what code does
5. **Reduced Duplication**: Functions promote code reuse (supports @mp018)
6. **Better Error Handling**: Functions provide clear boundaries for error management

## Integration with Module Systems {#sec-integration}

Functional encapsulation supports @mp044 (Functor-Module Correspondence):

```{r}
#| label: module-integration
#| eval: false

# M48_processing_customer_data/process_customer_data.R
source("../04_utils/fn_standardize_sales_data.R")
source("../04_utils/fn_aggregate_to_customer_level.R")
source("../04_utils/fn_calculate_rfm_metrics.R")

process_customer_data <- function(raw_data, config) {
  # Compose extracted functions
  standardized <- fn_standardize_sales_data(raw_data, config$platform_id, config$product_dict)
  aggregated <- fn_aggregate_to_customer_level(standardized, config$product_line_filter)
  metrics <- fn_calculate_rfm_metrics(aggregated, config$rfm_config)
  
  return(metrics)
}
```

## Next Steps for D-Series Refactoring {#sec-next-steps}

1. **Extract standardization function** from D01 and D02 duplicated code
2. **Extract aggregation function** from repeated customer-level processing
3. **Extract RFM calculation function** from complex metric calculations
4. **Create test suite** for extracted functions
5. **Refactor D01 and D02** to use extracted functions
6. **Validate functionality** through comprehensive testing

::: {.callout-tip}
## Implementation Priority
Start with the most duplicated functions first, as these provide immediate DRY compliance and the highest maintenance benefit.
:::

## Relationship to Other Principles {#sec-relationships}

This rule:

- **Implements @mp018 (DRY)**: Enables code reuse through function extraction
- **Supports @mp044 (Functor-Module)**: Provides building blocks for module creation
- **Follows @r021 (One Function One File)**: Organizes extracted functions properly
- **Enhances @p012 (app.R Is Global)**: Removes complex logic from main application file

---

*For related guidance, see @mp018 (Don't Repeat Yourself) and @mp044 (Functor-Module Correspondence).*