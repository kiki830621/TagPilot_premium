---
id: "T001"
title: "Update Scripts Templates"
type: "template-specification"
date_created: "2025-07-12"
date_modified: "2025-07-12"
author: "Claude"
implements:
  - "R113": "Four-Part Update Script Structure"
  - "MP031": "Initialization First"
  - "MP033": "Deinitialization Final"
derives_from:
  - "T000": "Template System Overview"
relates_to:
  - "MP042": "Runnable First"
  - "P076": "Error Handling Patterns"
---

# T01: Update Scripts Templates

## Core Purpose

T01 provides **standardized templates for update scripts** that implement the R113 Four-Part Structure, ensuring consistent error handling, resource management, and execution patterns across all system modification scripts.

## Template Architecture

### Initialization System Integration

**Critical**: Update scripts use the unified `autoinit()` system:

```r
# Set dependencies BEFORE initialization
needgoogledrive <- TRUE  # If Google Drive access needed
needpackages <- c("specific", "packages")  # If additional packages needed

# Use the unified autoinit system
autoinit()
```

The `autoinit()` function:
- Automatically detects script location and execution mode
- Loads appropriate initialization scripts based on location
- Loads all global scripts in the correct order
- Establishes database connections via `dbConnect_from_list()`
- Initializes required packages and dependencies
- Sets up the proper execution environment
- **Eliminates the need to manually source any files**
- **Initializes all standard path constants**

### Standard Path Constants

After `autoinit()` execution, the following standard path constants are available:

#### Core Directory Structure
```r
# Base directories
APP_DIR              # Project root (here::here())
COMPANY_DIR          # Parent directory of project
GLOBAL_DIR           # scripts/global_scripts/
GLOBAL_DATA_DIR      # scripts/global_scripts/global_data/
GLOBAL_PARAMETER_DIR # scripts/global_scripts/global_data/parameters/

# Application data directories  
APP_DATA_DIR         # data/app_data/
APP_PARAMETER_DIR    # data/app_data/parameters/
LOCAL_DATA_DIR       # data/local_data/

# Configuration
CONFIG_PATH          # app_config.yaml
```

#### Database Paths (from db_paths.R)
```r
# Database file paths (loaded automatically)
db_path_list         # Complete database path list
raw_data             # Raw data database path
processed_data       # Processed data database path  
app_data             # Application data database path
staged_data          # Staged data database path
transformed_data     # Transformed data database path
cleansed_data        # Cleansed data database path
```

#### Usage in Update Scripts
**Always use these constants instead of hardcoded paths:**

```r
# ✅ CORRECT - Use standard constants
source(file.path(GLOBAL_DIR, "04_utils", "fn_my_function.R"))
config <- yaml::read_yaml(CONFIG_PATH)
dbConnect_from_list("raw_data")

# ❌ INCORRECT - Hardcoded paths
source("../../../../global_scripts/04_utils/fn_my_function.R")
config <- yaml::read_yaml("app_config.yaml")
source(file.path("scripts", "global_scripts", "22_initializations", "sc_init.R"))
```

#### Path Standardization Benefits
1. **Platform Independence**: Paths work across different operating systems
2. **Project Portability**: Scripts work regardless of installation location
3. **Maintenance Efficiency**: Path changes only need updates in one place
4. **Error Reduction**: Eliminates hardcoded path errors
5. **Team Consistency**: All developers use identical path structure

### Four-Part Structure Implementation

```r
# ==============================================================================
# 1. INITIALIZE
# ==============================================================================
# - Set up execution tracking variables
# - Initialize environment and dependencies
# - Establish database connections
# - Load required functions and configurations

# ==============================================================================
# 2. MAIN
# ==============================================================================
# - Wrap core logic in tryCatch error handling
# - Perform the primary script operations
# - Set success/failure tracking variables
# - Log execution progress and results

# ==============================================================================
# 3. TEST
# ==============================================================================
# - Verify that operations completed successfully
# - Only execute if MAIN section succeeded
# - Perform data validation and quality checks
# - Set test completion tracking variables

# ==============================================================================
# 4. DEINITIALIZE
# ==============================================================================
# - Clean up all acquired resources
# - Close database connections
# - Report final execution status
# - Always execute regardless of previous errors
```

## Template Files and Locations

### Primary Template File
**Location**: `/scripts/global_scripts/00_principles/principles/R113_update_script_template.R`

**Usage**: Copy and customize for new update scripts

**Contents**:
- Complete four-part structure
- Placeholder values for customization
- Comprehensive error handling
- Resource management patterns
- Execution tracking and logging

### Template Generation Utility
**Location**: `/scripts/global_scripts/04_utils/fn_create_update_script.R`

**Functions**:
- `create_update_script()`: Programmatic template generation
- `create_update_script_interactive()`: Interactive template creation

**Features**:
- Automatic placeholder replacement
- Directory creation and file validation
- Overwrite protection
- Customization guidance

## Template Usage Examples

### Example 1: Data Import Script
```r
# amz_D03_00.R - Import product Profiles for Amazon
# D03_00: Import product Properties from External Data
# Follows R113: Four-Part Update Script Structure

# ==============================================================================
# 1. INITIALIZE
# ==============================================================================

# Initialize script execution tracking
script_success <- FALSE
test_passed <- FALSE
main_error <- NULL

# Initialize environment using autoinit system
# Set required dependencies before initialization
needgoogledrive <- TRUE

# Initialize using unified autoinit system
autoinit()

# Establish database connections using initialized system
dbConnect_from_list("raw_data")

message("INITIALIZE: Amazon product profiles import script initialized")

# ==============================================================================
# 2. MAIN
# ==============================================================================

tryCatch({
  message("MAIN: Starting Amazon product profiles import...")

  # Import product profiles for all active product lines
  import_product_profiles(
    db_connection = raw_data,
    product_line_df = df_product_line,
    google_sheet_id = "16-k48xxFzSZm2p8j9SZf4V041fldcYnR8ectjsjuxZQ",
    sheet_name_prefix = "product_profile"
  )

  script_success <- TRUE
  message("MAIN: Amazon product profiles import completed successfully")

}, error = function(e) {
  main_error <<- e
  script_success <<- FALSE
  message("MAIN ERROR: ", e$message)
})

# ==============================================================================
# 3. TEST
# ==============================================================================

if (script_success) {
  tryCatch({
    message("TEST: Verifying product profiles import...")

    # Check if df_product_profile_dictionary table exists and has data
    table_name <- "df_product_profile_dictionary"
    if (dbExistsTable(raw_data, table_name)) {
      query <- "SELECT COUNT(*) as count FROM df_product_profile_dictionary"
      product_count <- dbGetQuery(raw_data, query)$count

      if (product_count > 0) {
        test_passed <- TRUE
        message("TEST: Verification successful - ", product_count,
                " product profiles imported")
      } else {
        test_passed <- FALSE
        message("TEST: Verification failed - no product profiles found in table")
      }
    } else {
      test_passed <- FALSE
      message("TEST: Verification failed - ", table_name,
              " table does not exist")
    }

  }, error = function(e) {
    test_passed <<- FALSE
    message("TEST ERROR: ", e$message)
  })
} else {
  message("TEST: Skipped due to main script failure")
}

# ==============================================================================
# 4. DEINITIALIZE
# ==============================================================================

# Clean up database connections and resources using autodeinit system
autodeinit()

# Report final status
if (script_success && test_passed) {
  message("DEINITIALIZE: Script completed successfully with verification")
  return_status <- TRUE
} else if (script_success && !test_passed) {
  message("DEINITIALIZE: Script completed but verification failed")
  return_status <- FALSE
} else {
  message("DEINITIALIZE: Script failed during execution")
  if (!is.null(main_error)) {
    message("DEINITIALIZE: Error details - ", main_error$message)
  }
  return_status <- FALSE
}

message("DEINITIALIZE: Amazon product profiles import script completed")
```

### Example 2: Data Processing Script
```r
# Process customer segmentation data
# Generated using create_update_script()

create_update_script(
  script_name = "amz_D04_00",
  description = "Process Amazon customer segments",
  derivation_id = "D04_00",
  derivation_desc = "Customer Segmentation Analysis",
  main_operation = "customer segmentation processing",
  verification_desc = "customer segment results",
  target_dir = "scripts/update_scripts"
)
```

## Template Customization Guidelines

### Required Customizations
1. **Script Header**: Update script name, description, and derivation ID
2. **Dependencies**: Specify required packages and functions
3. **Main Logic**: Implement the core processing operations
4. **Verification**: Define appropriate test conditions
5. **Database Connections**: Specify target databases

### Optional Customizations
1. **Error Handling**: Add domain-specific error handling
2. **Logging**: Enhance logging for specific operations
3. **Resource Management**: Add cleanup for additional resources
4. **Performance Monitoring**: Include timing and performance metrics

## Template Validation

### Compliance Checks
Templates must satisfy these requirements:

1. **Structural Compliance**:
   - All four sections must be present
   - Sections must be in correct order
   - Required variables must be initialized

2. **Error Handling Compliance**:
   - MAIN section wrapped in tryCatch
   - Error variables properly set
   - Resource cleanup always executed

3. **Resource Management Compliance**:
   - All opened connections are closed
   - All acquired resources are released
   - Cleanup code in DEINITIALIZE section

### Validation Tools
```r
# Validate update script compliance
validate_update_script <- function(script_path) {
  # Check four-part structure
  # Verify error handling patterns
  # Confirm resource management
  # Return compliance report
}
```

## Common Template Patterns

### Pattern 1: Database Operations
```r
# INITIALIZE: Database connections
dbConnect_from_list("target_database")

# MAIN: Database operations with transactions
tryCatch({
  dbBegin(target_database)
  # Perform operations
  dbCommit(target_database)
  script_success <- TRUE
}, error = function(e) {
  dbRollback(target_database)
  main_error <<- e
  script_success <<- FALSE
})

# TEST: Verify database changes
# DEINITIALIZE: Close connections
```

### Pattern 2: File Processing
```r
# INITIALIZE: File system setup
input_dir <- "data/input"
output_dir <- "data/output"
dir.create(output_dir, showWarnings = FALSE)

# MAIN: File processing with progress tracking
# TEST: Verify output files
# DEINITIALIZE: Cleanup temporary files
```

### Pattern 3: API Integration
```r
# INITIALIZE: API client setup
api_client <- initialize_api_client()

# MAIN: API operations with rate limiting
# TEST: Verify API responses
# DEINITIALIZE: Close API connections
```

## Template Evolution and Maintenance

### Version Management
- Templates follow semantic versioning
- Breaking changes require migration guides
- Backward compatibility considerations

### Usage Analytics
- Track template adoption rates
- Identify common customization patterns
- Monitor compliance across codebase

### Feedback Integration
- Collect developer feedback on template usability
- Identify pain points and improvement opportunities
- Enhance templates based on real-world usage

## Integration with Development Tools

### IDE Integration
- Syntax highlighting for template sections
- Code folding for section organization
- Snippet support for common patterns

### Automated Generation
- Command-line tools for template creation
- Integration with project scaffolding
- Batch generation for multiple scripts

### Quality Assurance
- Automated compliance checking
- Code review guidelines
- Testing framework integration

## Conclusion

T01 Update Scripts Templates provide a robust foundation for creating consistent, reliable system modification scripts. By implementing the R113 Four-Part Structure through standardized templates and generation tools, the system ensures that all update scripts follow best practices for error handling, resource management, and execution tracking.

The template system balances flexibility with consistency, allowing developers to customize scripts for specific needs while maintaining adherence to core architectural principles. This approach significantly reduces development time while improving code quality and system reliability.