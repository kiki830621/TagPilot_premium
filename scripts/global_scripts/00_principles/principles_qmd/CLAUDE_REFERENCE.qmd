---
id: "CLAUDE_REF"
title: "Claude Development Reference Guide"
type: "claude-reference"
date_created: "2025-07-15"
date_modified: "2025-07-15"
author: "Claude"
purpose: "Quick reference guide for Claude when working with this codebase"
priority: "CRITICAL - READ FIRST"
---

# Claude Development Reference Guide

## üö® PRE-TASK CHECKLIST (MUST READ EVERY TIME)

### 1. Working Directory Setup
- [ ] **ALWAYS** change to project root: `/Users/che/Library/CloudStorage/Dropbox/che_workspace/projects/ai_martech/l3_enterprise/WISER`
- [ ] Verify `app_config.yaml` exists in current directory
- [ ] Confirm `autoinit()` function works before proceeding

### 2. Environment Differences (RStudio vs Command Line)
**IMPORTANT**: There are key differences between RStudio and command line R environments:

#### RStudio Environment (Normal Usage)
- `.Rprofile` automatically loads on startup
- `autoinit()` function immediately available
- All ETL scripts work directly: `Rscript scripts/update_scripts/amz_ETL04_0IM.R`

#### Command Line Environment (Testing/Debugging)
- `.Rprofile` must be manually loaded
- Need to source `.Rprofile` before using `autoinit()`
- Required pattern for command line testing:
```bash
# CORRECT - Load .Rprofile first
R --vanilla -e "source('.Rprofile'); autoinit(); source('scripts/update_scripts/amz_ETL04_0IM.R')"

# WRONG - Direct script execution will fail
Rscript scripts/update_scripts/amz_ETL04_0IM.R  # ‚ùå autoinit() not found
```

#### Key Environment Files
- `.Rprofile` ‚Üí Sources `scripts/global_scripts/22_initializations/sc_Rprofile.R`
- `sc_Rprofile.R` ‚Üí Defines `autoinit()` function in `.InitEnv`
- `autoinit()` ‚Üí Automatically detects script location and sets `OPERATION_MODE`

### 3. Script Execution Pattern
```bash
# CORRECT - from project root
cd /Users/che/Library/CloudStorage/Dropbox/che_workspace/projects/ai_martech/l3_enterprise/WISER
Rscript scripts/update_scripts/script_name.R

# WRONG - from subdirectory
cd scripts/update_scripts
Rscript script_name.R  # ‚ùå WILL FAIL
```

### 4. Common Error Prevention
- [ ] Check if function exists before calling it
- [ ] Use named parameters for complex functions (especially `radioButtons`)
- [ ] Add proper error handling with `tryCatch()`
- [ ] Validate data types before operations

## üìã QUICK COMMAND REFERENCE

### ETL Pipeline Commands (Run from project root)
```bash
# ETL04 - Competitor Analysis
Rscript scripts/update_scripts/amz_ETL04_0IM.R    # Import
Rscript scripts/update_scripts/amz_ETL04_1ST.R    # Staging
Rscript scripts/update_scripts/amz_ETL04_2TR.R    # Transform

# ETL03 - product Profiles
Rscript scripts/update_scripts/amz_ETL03_0IM.R                      # Main profiles
Rscript scripts/update_scripts/amz_ETL03_0IM_review_properties.R    # Review properties
Rscript scripts/update_scripts/amz_ETL03_0IM_product_reviews.R      # Product reviews
Rscript scripts/update_scripts/amz_ETL03_1ST.R                      # Staging
Rscript scripts/update_scripts/amz_ETL03_2TR.R                      # Transform
```

### Database Operations
```r
# Standard database connections (after autoinit())
raw_data <- dbConnectDuckdb(db_path_list$raw_data, read_only = FALSE)
staged_data <- dbConnectDuckdb(db_path_list$staged_data, read_only = TRUE)
```

### Database Content Inspection
```bash
# Export all DuckDB tables to CSV for inspection
Rscript scripts/update_scripts/all_S02_00.R

# Then check exported data at:
# /data/database_to_csv/
# This creates CSV files for all tables in all databases
```

### Testing Commands
```bash
# Test individual scripts
Rscript scripts/update_scripts/script_name.R

# Check database status
Rscript scripts/update_scripts/check_db_status.R
```

## ‚ö†Ô∏è CRITICAL ERROR PATTERNS TO AVOID

### 1. Function Parameter Specification (MP081)
```r
# CORRECT - Named parameters
radioButtons(
  inputId = "platform",
  label = NULL,
  choices = c("Amazon" = 2, "All Platforms" = 0),
  selected = 2
)

# WRONG - Positional parameters
radioButtons("platform", NULL, c("Amazon" = 2, "All Platforms" = 0), 2)
```

### 2. Data Access Patterns (R116)
```r
# CORRECT - Proper validation
if (!is.null(x) && !is.na(x) && as.numeric(x) > 0) {
  # Safe to use x
}

# WRONG - Missing validation
if (x > 0) {  # Can fail with NULL or NA
  # Unsafe code
}
```

### 3. Variable Name Consistency
```r
# CORRECT - Consistent naming throughout
platform_id <- as.character(input$platform)
platform_name <- platform_map[platform_id]
showNotification(paste("Switched to", platform_name))  # Same variable
log_data$details <- platform_name  # Same variable

# WRONG - Inconsistent naming
platform_id <- as.character(input$platform)
platform_name <- platform_map[platform_id]
showNotification(paste("Switched to", platform_text))  # Different variable
```

## üîß FUNCTION DEVELOPMENT GUIDELINES

### 1. Function Parameters
- Always include `skip_validation = FALSE` for import functions
- Use named parameters for complex functions
- Provide default values for optional parameters
- Document all parameters with roxygen2 comments

### 2. Error Handling
```r
# Standard error handling pattern
tryCatch({
  # Main logic here
  result <- process_data(input_data)
  
}, error = function(e) {
  message("ERROR: ", e$message)
  return(NULL)
})
```

### 3. Database Operations
```r
# Standard database write pattern
if (nrow(data) > 0) {
  dbWriteTable(connection, table_name, data, overwrite = TRUE)
  message("Successfully wrote ", nrow(data), " rows to ", table_name)
} else {
  message("No data to write")
}
```

## üìÅ FILE ORGANIZATION RULES

### 1. Script Naming
- ETL scripts: `platform_ETL##_PHASE.R` (e.g., `amz_ETL04_0IM.R`)
- Functions: `fn_function_name.R` (e.g., `fn_import_competitor_products.R`)
- Test scripts: `test_functionality.R`

### 2. Directory Structure
```
scripts/
‚îú‚îÄ‚îÄ global_scripts/
‚îÇ   ‚îú‚îÄ‚îÄ 00_principles/         # Principles and guidelines
‚îÇ   ‚îú‚îÄ‚îÄ 05_etl_utils/         # ETL utility functions
‚îÇ   ‚îî‚îÄ‚îÄ 04_utils/             # General utility functions
‚îî‚îÄ‚îÄ update_scripts/           # Main execution scripts
```

### 3. Function Organization
- One function per file (R021)
- Functions in `global_scripts/` for reusability
- Platform-specific functions in appropriate subdirectories

## üß™ TESTING AND VALIDATION

### 1. Before Making Changes
```bash
# Check current database status
Rscript scripts/update_scripts/check_db_status.R

# Run relevant tests
Rscript path/to/test_script.R
```

### 2. After Making Changes
```bash
# Test the modified script
Rscript scripts/update_scripts/modified_script.R

# Verify database integrity
# Check that tables exist and have expected row counts
```

### 3. ETL Pipeline Testing
```bash
# Test complete ETL04 pipeline
Rscript scripts/update_scripts/amz_ETL04_0IM.R
Rscript scripts/update_scripts/amz_ETL04_1ST.R
Rscript scripts/update_scripts/amz_ETL04_2TR.R

# Verify data flow: raw ‚Üí staged ‚Üí transformed
```

## üìù DOCUMENTATION STANDARDS

### 1. Function Documentation
```r
#' Brief description of function
#'
#' Detailed description of what the function does
#'
#' @param param1 Description of parameter 1
#' @param param2 Description of parameter 2
#' @param skip_validation Logical. If TRUE, skips validation checks
#'
#' @return Description of return value
#'
#' @examples
#' \dontrun{
#' result <- function_name(param1 = "value", param2 = TRUE)
#' }
#'
#' @export
```

### 2. Script Headers
```r
# script_name.R - Brief description
# ETL## Phase #: Detailed description
# Follows R113: Four-part update script structure

# ==============================================================================
# 1. INITIALIZE
# ==============================================================================
```

## üîÑ WORKFLOW REMINDERS

### 1. Development Sequence
1. Change to project root directory
2. Read relevant principles and documentation
3. Plan changes and update todo list
4. Implement changes with proper error handling
5. Test thoroughly
6. Update documentation if needed

### 2. Git and Version Control
- Never commit without testing
- Use descriptive commit messages
- Always check git status before commits
- Use proper branching for major changes

### 3. Code Quality
- Follow existing code style
- Use meaningful variable names
- Add comments for complex logic
- Maintain consistent formatting

## üöÄ PERFORMANCE OPTIMIZATION

### 1. Database Operations
- Use appropriate database connections (read-only when possible)
- Batch operations when dealing with large datasets
- Close connections properly after use

### 2. Memory Management
- Clean up large objects when done
- Use `rm()` for temporary variables
- Monitor memory usage in long-running scripts

## üîç DEBUGGING TIPS

### 1. Common Issues
- **"autoinit not found"**: 
  - **In RStudio**: Check if `.Rprofile` loaded correctly
  - **In command line**: Must source `.Rprofile` first
  - **Wrong working directory**: Must be in project root
- **Database connection errors**: Check `db_path_list` configuration
- **Function not found**: Check if global scripts sourced properly
- **Parameter errors**: Use named parameters

### 2. Debugging Tools
```r
# Check current working directory
getwd()

# Check if file exists
file.exists("app_config.yaml")

# Check object availability
exists("autoinit")
ls()  # List all objects in environment

# Environment-specific debugging
# Check if .Rprofile loaded
exists(".InitEnv") && is.environment(.InitEnv)

# Check autoinit function location
if (exists(".InitEnv")) {
  exists("autoinit", envir = .InitEnv)
}

# For command line debugging
# source(".Rprofile")  # Load .Rprofile manually
# autoinit()          # Initialize environment
```

## üìä DATA PIPELINE SPECIFICS

### 1. ETL04 - Competitor Analysis
- **Purpose**: Process competitor products from Google Sheets
- **Key Function**: `import_competitor_products()` with `skip_validation = TRUE`
- **Output**: `df_amz_competitor_product_id` tables in respective databases

### 2. ETL03 - product Profiles
- **Purpose**: Process Amazon product profiles
- **Multiple Import Scripts**: Main profiles, review properties, product reviews
- **Column Mapping**: Uses `app_configs$list_colname_aliases`

### 3. Database Schema
```
raw_data.duckdb       ‚Üí staged_data.duckdb       ‚Üí transformed_data.duckdb
‚îú‚îÄ‚îÄ df_*              ‚îú‚îÄ‚îÄ df_*___staged          ‚îú‚îÄ‚îÄ df_*___transformed
‚îî‚îÄ‚îÄ Import phase      ‚îî‚îÄ‚îÄ Staging phase         ‚îî‚îÄ‚îÄ Transform phase
```

## üéØ SUCCESS CRITERIA

### 1. Script Execution Success
- [ ] Script runs without errors
- [ ] Expected output is generated
- [ ] Database tables created/updated correctly
- [ ] Row counts match expectations

### 2. Code Quality Success
- [ ] Follows naming conventions
- [ ] Includes proper error handling
- [ ] Has appropriate documentation
- [ ] Uses named parameters for complex functions

### 3. Integration Success
- [ ] Works with existing ETL pipeline
- [ ] Compatible with current database schema
- [ ] Doesn't break existing functionality
- [ ] Follows established patterns

---

## üìû WHEN IN DOUBT

1. **Check the principles**: Look in `00_principles/` for relevant guidelines
2. **Follow existing patterns**: Look at similar functions/scripts for reference
3. **Test thoroughly**: Always test changes before considering them complete
4. **Document changes**: Update relevant documentation when making modifications

**Remember**: This codebase values consistency, reliability, and maintainability. When in doubt, choose the safer, more explicit approach.